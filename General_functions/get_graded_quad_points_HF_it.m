function G_data = get_graded_quad_points_HF_it(G_data, C_wl_quad_outer,...
    C_wl_quad_inner, k, Lgrad_coeff, alpha)
% In this function we will compute the graded quadrature points needed for
% the high frequency iterative method. There will be nodes for the outer
% quadrature points and the inner quadrature points. Should be more
% quadrature points for the inner as opposed to the outer

[G_data.x_1_q_outer, G_data.y_1_q_outer, G_data.x_2_q_outer, ...
    G_data.y_2_q_outer, G_data.t_grid_outer, G_data.t_mid_q_outer, ...
    G_data.w_outer, G_data.N_outer, G_data.L] = ...
    discretistion_vars_graded(G_data.G, C_wl_quad_outer, k,...
    Lgrad_coeff, alpha);

% flipping and combining for ease - may remove
G_data.w_comb_outer = [G_data.w_outer; flip(G_data.w_outer)];
G_data.x_q_comb_outer = [G_data.x_1_q_outer; flip(G_data.x_2_q_outer)];
G_data.y_q_comb_outer = [G_data.y_1_q_outer; flip(G_data.y_2_q_outer)];
G_data.t_mid_q_comb_outer = [G_data.t_mid_q_outer; G_data.L - ...
    flip(G_data.t_mid_q_outer)];
G_data.t_grid_comb_outer = [G_data.t_grid_outer; G_data.L - ...
    flip( G_data.t_grid_outer(1:end-1))];



[G_data.x_1_q_inner, G_data.y_1_q_inner, G_data.x_2_q_inner, ...
    G_data.y_2_q_inner, G_data.t_grid_inner, G_data.t_mid_q_inner, ...
    G_data.w_inner, G_data.N_inner, G_data.L] = ...
    discretistion_vars_graded(G_data.G, C_wl_quad_inner, k,...
    Lgrad_coeff, alpha);

% flipping and combining for ease - may remove
G_data.w_comb_inner = [G_data.w_inner; flip(G_data.w_inner)];
G_data.x_q_comb_inner = [G_data.x_1_q_inner; flip(G_data.x_2_q_inner)];
G_data.y_q_comb_inner = [G_data.y_1_q_inner; flip(G_data.y_2_q_inner)];
G_data.t_mid_q_comb_inner = [G_data.t_mid_q_inner; G_data.L - ...
    flip(G_data.t_mid_q_inner)];
G_data.t_grid_comb_inner = [G_data.t_grid_inner; G_data.L - ...
    flip( G_data.t_grid_inner(1:end-1))];
